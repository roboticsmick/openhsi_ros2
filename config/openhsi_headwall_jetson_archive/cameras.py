# FILE: openhsi/cameras.py

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/cameras/cameras.ipynb.

# %% auto 0
__all__ = [
    "WebCamera",
    "switched_camera",
    "FlirCameraBase",
    "FlirCamera",
    "SharedFlirCamera",
    "LucidCameraBase",
    "LucidCamera",
    "SharedLucidCamera",
    "XimeaCameraBase",
    "XimeaCamera",
    "SharedXimeaCamera",
]

# %% ../nbs/api/cameras/cameras.ipynb 5
# monkey patching class methods using @patch
from fastcore.foundation import *
from fastcore.foundation import patch

# bring forth **kwargs from an inherited class for documentation
from fastcore.meta import delegates

# external
import time
import datetime
from datetime import timezone  # Explicit import for timestamping
import numpy as np
import ctypes
import matplotlib.pyplot as plt
import warnings
from tqdm import tqdm
from functools import partial

from typing import Tuple

# internal
from .capture import OpenHSI
from .shared import SharedOpenHSI


# %% ../nbs/api/cameras/cameras.ipynb 7
@delegates()
class WebCamera(OpenHSI):
    """Interface for webcam to test OpenHSI functionality"""

    def __init__(self, mode: str = None, **kwargs):
        """Initialise Webcam"""
        super().__init__(**kwargs)

        import cv2

        # Check if the webcam is opened correctly
        self.vid = cv2.VideoCapture(0)
        if not self.vid.isOpened():
            raise IOError("Cannot open webcam")

        self.rgb2gray = partial(cv2.cvtColor, code=cv2.COLOR_RGB2GRAY)
        self.resize = partial(
            cv2.resize,
            dsize=tuple(np.flip(self.settings["resolution"])),
            interpolation=cv2.INTER_AREA,
        )
        self.close = cv2.destroyAllWindows

    def start_cam(self):
        pass

    def stop_cam(self):
        self.vid.release()
        self.close()

    def get_img(self) -> np.ndarray:
        ret, frame = self.vid.read()
        frame = self.rgb2gray(frame)
        frame = self.resize(frame)
        return frame, time.time()  # Return tuple to match Ximea

    def get_temp(self) -> float:
        return 20.0


# %% ../nbs/api/cameras/cameras.ipynb 12
def switched_camera(
    cam_class: str = None,  # Camera Class Name from openhsi.cameras
    n_lines: int = 128,  # how many along-track pixels
    processing_lvl: int = 0,  # desired processing done in real time
    json_path: str = "/media/pi/fastssd/cals/flir_settings.json",  # path to settings file
    cal_path: str = "/media/pi/fastssd/cals/flir_calibration.pkl",  # path to calibration file
    preconfig_meta: str = "/media/pi/fastssd/cals/preconfig_metadata.json",  # path to metadata file
    ssd_dir: str = "/media/pi/fastssd",  # path to SSD
    toggle_interface=None,  # toggle_interface that controls collection
):
    """If `toggle_interface.status` is True, collect with the camera until switched is False."""

    cam = cam_class(
        n_lines=n_lines,
        processing_lvl=processing_lvl,
        json_path=json_path,
        cal_path=cal_path,
    )
    cam.start_cam()
    while toggle_interface.status == True:  # collect while go button is on.
        cam.collect()
        if "p" in locals():
            p.join()  # wait for the last process to finish so we don't modify the data when it's being saved
            pass
        p = cam.save(ssd_dir, preconfig_meta_path=preconfig_meta)

    cam.stop_cam()


# %% ../nbs/api/cameras/flir.ipynb 6
@delegates()
class FlirCameraBase:
    """Interface for FLIR camera"""

    def __init__(self, **kwargs):
        """Initialise FLIR camera"""
        super().__init__(**kwargs)

        from simple_pyspin import Camera

        self.flircam = Camera()
        self.flircam.init()
        self.flircam.GainAuto = "Off"
        self.flircam.Gain = 0
        self.flircam.AcquisitionFrameRateAuto = "Off"
        self.flircam.AcquisitionFrameRateEnabled = True
        self.flircam.AcquisitionFrameRate = int(
            min(1_000 / (self.settings["exposure_ms"] + 1), 120)
        )

        self.flircam.ExposureAuto = "Off"
        self.flircam.ExposureTime = self.settings["exposure_ms"] * 1e3  # convert to us
        self.flircam.GammaEnabled = False

        self.flircam.Width = (
            self.flircam.SensorWidth
            if self.settings["win_resolution"][1] == 0
            else self.settings["win_resolution"][1]
        )
        self.flircam.Height = (
            self.flircam.SensorHeight
            if self.settings["win_resolution"][0] == 0
            else self.settings["win_resolution"][0]
        )
        self.flircam.OffsetY, self.flircam.OffsetX = self.settings["win_offset"]

    def start_cam(self):
        self.flircam.start()

    def stop_cam(self):
        self.flircam.stop()

    def __close__(self):
        self.flircam.close()

    def get_img(self) -> Tuple[np.ndarray, float]:
        return self.flircam.get_array(), time.time()

    def get_temp(self) -> float:
        return self.flircam.DeviceTemperature

    def set_exposure(self, exposure_ms: float):
        """sets the FLIR camera exposure time to `exposure_ms`."""

        if exposure_ms < self.flircam.ExposureMinAbsVal_Float / 1000:
            exposure_ms = self.flircam.ExposureMinAbsVal_Float / 1000

        self.settings["exposure_ms"] = exposure_ms

        self.flircam.AcquisitionFrameRateAuto = "Off"
        self.flircam.AcquisitionFrameRateEnabled = True
        self.flircam.AcquisitionFrameRate = int(
            min(1_000 / (self.settings["exposure_ms"] + 1), 120)
        )
        self.flircam.ExposureAuto = "Off"

        self.flircam.ExposureTime = self.settings["exposure_ms"] * 1e3  # convert to us


@delegates()
class FlirCamera(FlirCameraBase, OpenHSI):
    pass


# %% ../nbs/api/cameras/flir.ipynb 9
@delegates()
class SharedFlirCamera(FlirCameraBase, SharedOpenHSI):
    pass


# %% ../nbs/api/cameras/lucidvision.ipynb 6
@delegates()
class LucidCameraBase:
    """Core functionality for Lucid Vision Lab cameras

    Any keyword-value pair arguments must match the those avaliable in settings file. LucidCamera expects the ones listed below:

    - `binxy`: number of pixels to bin in (x,y) direction
    - `win_resolution`: size of area on detector to readout (width, height)
    - `win_offset`: offsets (x,y) from edge of detector for a selective
    - `exposure_ms`: is the camera exposure time to use
    - `pixel_format`: format of pixels readout sensor, ie Mono8, Mono10, Mono10p, Mono10Packed, Mono12, Mono12p, Mono12Packed, Mono16
    - `mac_addr`: str = "1c:0f:af:01:7b:a0",
    """

    def __init__(self, **kwargs):
        """Initialise Camera"""
        # https://thinklucid.com/downloads-hub/
        super().__init__(**kwargs)

        from arena_api.system import system as arsys
        from arena_api.system import DeviceNotFoundError

        self.arsys = arsys  # make avalaible for later access just in case.
        arsys.destroy_device()  # reset an existing connections.

        try:
            # self.arsys.device_infos # This line doesn't do anything useful
            # self.device = arsys.create_device(device_infos=[{"mac": mac_addr}])[0]
            devices = arsys.create_device()
            if not devices:
                raise RuntimeError(
                    "DeviceNotFoundError: Please connect a lucid vision camera and run again."
                )
            self.device = devices[0]
        except DeviceNotFoundError as exc:
            raise RuntimeError(
                "DeviceNotFoundError: Please connect a lucid vision camera and run again."
            ) from exc

        # allow api to optimise stream
        tl_stream_nodemap = self.device.tl_stream_nodemap
        tl_stream_nodemap["StreamAutoNegotiatePacketSize"].value = True
        tl_stream_nodemap["StreamPacketResendEnable"].value = True

        # init access to device settings
        self.deviceSettings = self.device.nodemap.get_node(
            [
                "AcquisitionFrameRate",
                "AcquisitionFrameRateEnable",
                "AcquisitionMode",
                "AcquisitionStart",
                "AcquisitionStop",
                "BinningHorizontal",
                "BinningVertical",
                "DevicePower",
                "DeviceTemperature",
                "DeviceUpTime",
                "DeviceUserID",
                "ExposureAuto",
                "ExposureTime",
                "Gain",
                "GammaEnable",
                "Height",
                "OffsetX",
                "OffsetY",
                "PixelFormat",
                "ReverseX",
                "ReverseY",
                "Width",
                "GevMACAddress",
                "DeviceSerialNumber",
            ]
        )

        # set pixel settings
        self.deviceSettings["BinningHorizontal"].value = self.settings["binxy"][
            0
        ]  # binning is symetric on this sensor, no need to set vertical
        self.deviceSettings["PixelFormat"].value = self.settings["pixel_format"]

        # always reset to no window.
        self.deviceSettings["OffsetY"].value = 0
        self.deviceSettings["OffsetX"].value = 0
        self.deviceSettings["Height"].value = self.deviceSettings["Height"].max
        self.deviceSettings["Width"].value = self.deviceSettings["Width"].max

        # print("Setting window to: height {}, offset y {}, width {}, offsetx {}".format(self.settings["win_resolution"][0],
        #                                                                     self.settings["win_offset"][0],
        #                                                                     self.settings["win_resolution"][1],
        #                                                                     self.settings["win_offset"][1])
        #      )

        # set window up.
        self.deviceSettings["Height"].value = (
            self.settings["win_resolution"][0]
            if self.settings["win_resolution"][0] > 0
            else self.deviceSettings["Height"].max
        )
        self.deviceSettings["Width"].value = (
            self.settings["win_resolution"][1]
            if self.settings["win_resolution"][1] > 0
            else self.deviceSettings["Width"].max
        )

        self.deviceSettings["OffsetY"].value = (
            self.settings["win_offset"][0]
            if self.settings["win_offset"][0] > 0
            else self.deviceSettings["OffsetY"].max
        )
        self.deviceSettings["OffsetX"].value = (
            self.settings["win_offset"][1]
            if self.settings["win_offset"][1] > 0
            else self.deviceSettings["OffsetX"].max
        )

        # set exposure realted props
        self.deviceSettings["ExposureAuto"].value = (
            "Off"  # always off as we need to match exposure to calibration data
        )
        self.set_exposure(self.settings["exposure_ms"])

        self.set_gain(0)  # default to 0 as we need to match to calibration data

        self.rows, self.cols = (
            self.deviceSettings["Height"].value,
            self.deviceSettings["Width"].value,
        )

        self.settings["camera_id"] = self.deviceSettings["DeviceUserID"].value

    def __exit__(self, *args, **kwargs):
        self.device.stop_stream()
        self.arsys.destroy_device()

    def start_cam(self):
        self.device.start_stream(1)

    def stop_cam(self):
        self.device.stop_stream()

    def set_exposure(self, exposure_ms: float):

        if exposure_ms < self.deviceSettings["ExposureTime"].min / 1000.0:
            exposure_us = self.deviceSettings["ExposureTime"].min
        else:
            exposure_us = exposure_ms * 1000.0

        nominal_framerate = 1_000_000.0 / exposure_us * 0.98

        # print("nominal_framerate {}, exposure_us {}".format(nominal_framerate,exposure_us))

        if nominal_framerate < self.deviceSettings["AcquisitionFrameRate"].max:
            self.deviceSettings["AcquisitionFrameRateEnable"].value = True
            self.deviceSettings["AcquisitionFrameRate"].value = nominal_framerate
        else:
            self.deviceSettings["AcquisitionFrameRateEnable"].value = False

        self.deviceSettings["ExposureTime"].value = (
            exposure_us  # requires time in us float
        )
        self.settings["exposure_ms"] = (
            self.deviceSettings["ExposureTime"].value / 1000.00
        )  # exposure time rounds, so storing actual value

    def set_gain(self, gain_val: float):
        self.deviceSettings["Gain"].value = gain_val * 1.0  # make float always

    def get_img(self) -> Tuple[np.ndarray, float]:
        image_buffer = self.device.get_buffer()
        capture_time = (
            time.time()
        )  # Capture host time as close to buffer return as possible
        if image_buffer.bits_per_pixel == 8:
            nparray_reshaped = np.ctypeslib.as_array(
                image_buffer.pdata, (image_buffer.height, image_buffer.width)
            ).copy()

        elif image_buffer.bits_per_pixel == 12 or image_buffer.bits_per_pixel == 10:
            split = np.ctypeslib.as_array(
                image_buffer.pdata, (image_buffer.buffer_size, 1)
            ).astype(np.uint16)
            fst_uint12 = (split[0::3] << 4) + (split[1::3] >> 4)
            snd_uint12 = (split[2::3] << 4) + (np.bitwise_and(15, split[1::3]))
            nparray_reshaped = np.reshape(
                np.concatenate((fst_uint12[:, None], snd_uint12[:, None]), axis=1),
                (image_buffer.height, image_buffer.width),
            )

        elif image_buffer.bits_per_pixel == 16:
            pdata_as16 = ctypes.cast(
                image_buffer.pdata, ctypes.POINTER(ctypes.c_ushort)
            )
            nparray_reshaped = np.ctypeslib.as_array(
                pdata_as16, (image_buffer.height, image_buffer.width)
            ).copy()

        # nparray_reshaped=np.ctypeslib.as_array(image_buffer,(1,image_buffer.buffer_size))
        self.device.requeue_buffer(image_buffer)
        return nparray_reshaped, capture_time

    def get_temp(self) -> float:
        return self.deviceSettings["DeviceTemperature"].value

    def get_mac(self) -> str:
        # Assumes `cam` is an instance of LucidCameraBase
        return ":".join(
            [
                "{}{}".format(a, b)
                for a, b in zip(
                    *[
                        iter(
                            "{:012x}".format(self.deviceSettings["GevMACAddress"].value)
                        )
                    ]
                    * 2
                )
            ]
        )


@delegates()
class LucidCamera(LucidCameraBase, OpenHSI):
    pass


# %% ../nbs/api/cameras/lucidvision.ipynb 9
@delegates()
class SharedLucidCamera(LucidCameraBase, SharedOpenHSI):
    pass


# %% ../nbs/api/cameras/ximea.ipynb 5
@delegates()
class XimeaCameraBase:
    """Core functionality for Ximea cameras"""

    def __init__(self, exposure_ms: float = 10, serial_num: str = None, **kwargs):
        super().__init__(**kwargs)  # Calls OpenHSI -> CameraProperties constructor

        from ximea import xiapi

        self.xiapi = xiapi
        self.xicam = self.xiapi.Camera()

        s_num_json = self.settings.get("serial_num", None)
        s_num_to_use = serial_num if serial_num is not None else s_num_json

        if s_num_to_use:
            print(f"Attempting to open XIMEA camera with S/N: {s_num_to_use}")
            self.xicam.open_device_by_SN(s_num_to_use)
        else:
            print("Attempting to open the FIRST available XIMEA camera.")
            self.xicam.open_device()

        actual_sn_bytes = self.xicam.get_device_sn()
        actual_sn = (
            actual_sn_bytes.decode("utf-8")
            if isinstance(actual_sn_bytes, bytes)
            else str(actual_sn_bytes)
        )
        print(f"Connected to XIMEA device S/N: {actual_sn}")
        self.settings["actual_serial_num"] = (
            actual_sn  # Store it back if read dynamically
        )

        try:
            self.xicam.stop_acquisition()
            print(
                "DEBUG XimeaCameraBase: Temporarily stopped acquisition before setting critical params."
            )
        except self.xiapi.Xi_error as e_stop:
            # XI_ACQUISITION_STOP_ALREADY_STOPPED = 105
            if e_stop.status == 105:
                print("DEBUG XimeaCameraBase: Acquisition was already stopped.")
            else:  # Log other errors but proceed cautiously
                print(
                    f"DEBUG XimeaCameraBase: Minor error stopping acquisition: {e_stop}"
                )

        # --- Step 1: Set Binning ---
        bin_vertical_ximea = self.settings.get("binxy", [1, 1])[0]
        bin_horizontal_ximea = self.settings.get("binxy", [1, 1])[1]
        if bin_vertical_ximea > 1 or bin_horizontal_ximea > 1:
            print(
                f"DEBUG XimeaCameraBase: Applying binning: VBin={bin_vertical_ximea}, HBin={bin_horizontal_ximea}"
            )
            self.xicam.set_param("binning_selector", "XI_BIN_SELECT_SENSOR")
            self.xicam.set_param("binning_vertical_mode", "XI_BIN_MODE_SUM")
            self.xicam.set_param("binning_horizontal_mode", "XI_BIN_MODE_SUM")
        self.xicam.set_binning_vertical(bin_vertical_ximea)
        self.xicam.set_binning_horizontal(bin_horizontal_ximea)

        # --- Step 2: Get Maximums and Increments *after* binning ---
        max_width_api = self.xicam.get_width_maximum()
        max_height_api = self.xicam.get_height_maximum()
        try:
            width_inc = self.xicam.get_width_increment()
            height_inc = self.xicam.get_height_increment()
            offset_x_inc = self.xicam.get_offsetX_increment()
            offset_y_inc = self.xicam.get_offsetY_increment()
        except self.xiapi.Xi_error as e_inc:
            raise RuntimeError(
                f"FATAL: Could not get parameter increments from XIMEA camera: {e_inc}. Cannot proceed."
            )

        # --- Step 3: Reset ROI to Full Frame AFTER binning ---
        self.xicam.set_offsetX(0)
        self.xicam.set_offsetY(0)
        self.xicam.set_width(max_width_api)
        self.xicam.set_height(max_height_api)

        # --- Step 4: Validate and Set Target Hardware ROI (XIMEA's Native Perspective) ---
        target_h_api = self.settings["win_resolution_h_hw_api"]
        target_w_api = self.settings["win_resolution_w_hw_api"]
        offset_y_api = self.settings["win_offset_y_hw_api"]
        offset_x_api = self.settings["win_offset_x_hw_api"]

        if offset_x_api % offset_x_inc != 0:
            warnings.warn(
                f"OffsetX API {offset_x_api} not multiple of {offset_x_inc}. Adjusting.",
                UserWarning,
                stacklevel=2,
            )
            offset_x_api = (offset_x_api // offset_x_inc) * offset_x_inc
        if offset_y_api % offset_y_inc != 0:
            warnings.warn(
                f"OffsetY API {offset_y_api} not multiple of {offset_y_inc}. Adjusting.",
                UserWarning,
                stacklevel=2,
            )
            offset_y_api = (offset_y_api // offset_y_inc) * offset_y_inc
        if target_w_api % width_inc != 0:
            warnings.warn(
                f"Width API {target_w_api} not multiple of {width_inc}. Adjusting (ceiling).",
                UserWarning,
                stacklevel=2,
            )
            target_w_api = ((target_w_api + width_inc - 1) // width_inc) * width_inc
        if target_h_api % height_inc != 0:
            warnings.warn(
                f"Height API {target_h_api} not multiple of {height_inc}. Adjusting (ceiling).",
                UserWarning,
                stacklevel=2,
            )
            target_h_api = ((target_h_api + height_inc - 1) // height_inc) * height_inc

        # Set ROI: dimensions first (at 0,0 offset), then set offsets.
        self.xicam.set_width(target_w_api)
        self.xicam.set_height(target_h_api)
        self.xicam.set_offsetX(offset_x_api)
        self.xicam.set_offsetY(offset_y_api)

        current_w, current_h = self.xicam.get_width(), self.xicam.get_height()
        current_ox, current_oy = self.xicam.get_offsetX(), self.xicam.get_offsetY()
        print(
            f"XIMEA hardware ROI after setting: H={current_h}, W={current_w}, OY={current_oy}, OX={current_ox}"
        )

        if not (
            current_h == target_h_api
            and current_w == target_w_api
            and current_ox == offset_x_api
            and current_oy == offset_y_api
        ):
            warnings.warn(
                f"XIMEA hardware ROI settings mismatch. Target: H={target_h_api},W={target_w_api},OY={offset_y_api},OX={offset_x_api}. Actual: H={current_h},W={current_w},OY={current_oy},OX={current_ox}.",
                UserWarning,
                stacklevel=2,
            )

        # --- Step 5: Other Settings ---
        self.set_exposure(self.settings["exposure_ms"])
        self.xicam.set_gain_direct(0.0)
        self.xicam.set_imgdataformat(self.settings["pixel_format"])
        self.xicam.disable_aeag()

        self.rows, self.cols = self.xicam.get_height(), self.xicam.get_width()
        print(
            f"XimeaCameraBase initialized. Final hardware capture shape: ({self.rows}, {self.cols})"
        )
        self.img = self.xiapi.Image()
        self._ximea_time_offset_sec = None
        self._first_frame_timestamped = False
        self._last_frame_relative_time_sec = 0.0  # For debug prints

    def __exit__(self, exc_type, exc_value, traceback):
        """Ensures camera is stopped and closed cleanly, especially for use with `with` statements."""
        print("XimeaCameraBase.__exit__ called. Cleaning up...")
        try:
            if hasattr(self, "xicam") and self.xicam.handle:
                self.stop_cam()  # Use the class's own stop method
        finally:
            if hasattr(self, "xicam") and self.xicam.handle:
                self.xicam.close_device()
                print("XIMEA camera device closed.")

    def set_exposure(self, exposure_ms: float):
        min_exp_us = self.xicam.get_exposure_minimum()
        max_exp_us = self.xicam.get_exposure_maximum()
        target_exp_us = float(exposure_ms) * 1000.0

        if target_exp_us < min_exp_us:
            print(
                f"Warning: Requested exposure {exposure_ms}ms ({target_exp_us:.0f}us) is below minimum {min_exp_us}us. Setting to minimum."
            )
            target_exp_us = min_exp_us
        elif target_exp_us > max_exp_us:
            print(
                f"Warning: Requested exposure {exposure_ms}ms ({target_exp_us:.0f}us) is above maximum {max_exp_us}us. Setting to maximum."
            )
            target_exp_us = max_exp_us

        self.xicam.set_exposure(int(target_exp_us))
        actual_exposure_us = self.xicam.get_exposure()
        actual_exposure_ms = actual_exposure_us / 1000.0
        self.settings["exposure_ms"] = actual_exposure_ms
        print(
            f"DEBUG XimeaCameraBase: Exposure set to {actual_exposure_ms:.3f} ms (target: {exposure_ms} ms, actual_us: {actual_exposure_us} us)"
        )

    def start_cam(self):
        print("DEBUG XimeaCameraBase: start_cam() called")
        self._first_frame_timestamped = False
        self._ximea_time_offset_sec = None
        self.xicam.start_acquisition()
        print("DEBUG XimeaCameraBase: XIMEA acquisition started.")

    def stop_cam(self):
        print("DEBUG XimeaCameraBase: stop_cam() called")
        try:
            if hasattr(self, "xicam") and self.xicam.handle:
                self.xicam.stop_acquisition()
                print("DEBUG XimeaCameraBase: XIMEA acquisition stopped.")
        except self.xiapi.Xi_error as e_stop:
            if e_stop.status == 105:  # XI_ACQUISITION_STOP_ALREADY_STOPPED
                print(
                    "DEBUG XimeaCameraBase: Acquisition was already stopped when stop_cam() was called."
                )
            else:
                print(
                    f"DEBUG XimeaCameraBase: Error stopping acquisition in stop_cam(): {e_stop}"
                )

    def get_img(self) -> Tuple[np.ndarray, float]:
        self.xicam.get_image(self.img)
        current_system_time_sec = time.time()

        if hasattr(self.img, "tsSec") and hasattr(self.img, "tsUSec"):
            ximea_relative_time_sec = self.img.tsSec + (self.img.tsUSec / 1_000_000.0)

            if not self._first_frame_timestamped:
                self._ximea_time_offset_sec = (
                    current_system_time_sec - ximea_relative_time_sec
                )
                self._first_frame_timestamped = True
                print(f"--- XIMEA First Frame Sync ---")
                print(f"  XIMEA relative time: {ximea_relative_time_sec:.6f} s")
                print(f"  System time: {current_system_time_sec:.6f} s")
                print(
                    f"  Calculated offset (System - XIMEA_relative): {self._ximea_time_offset_sec:.6f} s"
                )

            if self._ximea_time_offset_sec is not None:
                corrected_ximea_epoch_time_sec = (
                    ximea_relative_time_sec + self._ximea_time_offset_sec
                )
            else:
                corrected_ximea_epoch_time_sec = current_system_time_sec
                print(
                    f"Warning: XIMEA time offset not yet calculated, using current system time."
                )

            # --- DEBUG PRINTS for subsequent frames ---
            # Corrected condition to print for frames after the first one
            if (
                self._last_frame_relative_time_sec != 0
                and self._last_frame_relative_time_sec != ximea_relative_time_sec
            ):
                # Uncomment the block below for extremely verbose per-frame timestamp debugging
                # dt_obj = datetime.fromtimestamp(corrected_ximea_epoch_time_sec, tz=timezone.utc)
                # print(f"--- XIMEA Frame Debug ---")
                # print(f"  Corrected XIMEA epoch time: {corrected_ximea_epoch_time_sec:.6f} s ({dt_obj.isoformat()})")
                pass

            self._last_frame_relative_time_sec = ximea_relative_time_sec
            final_timestamp_sec = corrected_ximea_epoch_time_sec
        else:
            print(f"--- XIMEA Frame Debug ---")
            print(f"  XIMEA tsSec/tsUSec attributes NOT FOUND on self.img.")
            print(f"  Falling back to system time for this frame.")
            final_timestamp_sec = current_system_time_sec
            if not self._first_frame_timestamped:
                self._first_frame_timestamped = True

        return self.img.get_image_data_numpy(), final_timestamp_sec

    def get_temp(self) -> float:
        return self.xicam.get_temp()


# XimeaCamera and SharedXimeaCamera remain the same
@delegates()
class XimeaCamera(XimeaCameraBase, OpenHSI):
    pass


# %% ../nbs/api/cameras/ximea.ipynb 9
@delegates()
class SharedXimeaCamera(XimeaCameraBase, SharedOpenHSI):
    pass
